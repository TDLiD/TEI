<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<link rel="stylesheet" type="text/css" href="https://npmcdn.com/flatpickr/dist/themes/dark.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>



<style>
    /* 1. 기존 기본 구조 유지 */
    .schedule-cal th { padding: 12px 0; color: #64748b; font-size: 0.75rem; font-weight: 800; border-bottom: 1px solid #1e293b; }

    .schedule-cal td {
        position: relative; 
        height: 120px;
        width: 14.28%;
        vertical-align: top;
        padding-top: 30px; 
        border: 0.5px solid #1e293b; 
        transition: 0.2s;
        cursor: pointer;
    }

    #scheduleBody { position: relative; }

    /* 2. 수정 및 추가된 일정 항목(event-item) 스타일 */
    .event-item {
        position: absolute;
        z-index: 10;
        height: 22px;
        line-height: 22px;
        padding: 0 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 700;
        background: #3b82f6; /* 기본 색상 */
        color: white;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        margin-left: 2px;
        
        /* [추가] 내부 글자(제목 + 작성자) 배치를 위한 Flex 설정 */
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
    }

    /* [추가] 일정 제목 영역 (왼쪽 정렬) */
    .ev-title-text { 
        overflow: hidden; 
        text-overflow: ellipsis; 
        white-space: nowrap; 
        flex: 1; 
    }

    /* [추가] 우측 STAFF 이름 태그 스타일 */
    .ev-author-text { 
        opacity: 0.8; 
        font-size: 9px; 
        font-weight: 800; 
        background: rgba(0, 0, 0, 0.2); 
        padding: 0 4px; 
        border-radius: 3px;
        flex-shrink: 0; /* 이름이 잘리지 않도록 설정 */
    }

    /* 3. 기타 인터랙션 및 모달 스타일 유지 */
    .ev-time-text { font-weight: 800; margin-right: 4px; opacity: 0.9; }
    .event-item:active { cursor: grabbing; transform: scale(0.98); }

    .modal-input { 
        width: 100%; border: 1px solid #1e293b; background: #0f172a; 
        padding: 0.75rem; color: white; font-size: 0.875rem; outline: none; border-radius: 12px;
    }
    .modal-input:disabled { opacity: 0.6; cursor: not-allowed; }

    .memo-display {
        background: rgba(168, 85, 247, 0.1); 
        border: 1px solid rgba(168, 85, 247, 0.3);
        border-radius: 12px;
        padding: 12px;
        margin-top: 10px;
    }

    /* [팁] 여러 줄 겹칠 때 시각적 구분을 위한 색상 (선택 사항) */
    .event-item:nth-child(even) { background-color: #2563eb; } /* 짝수번째 일정 색상 미세 조정 */
</style>


<div class="animate-fadeIn">
    <div class="flex justify-between items-center mb-8">
        <div class="flex items-center gap-6">
            <h2 id="calMonthYear" class="text-2xl font-black text-white italic underline decoration-blue-500 underline-offset-8 uppercase tracking-tighter"></h2>
            <div class="flex bg-slate-900 rounded-xl p-1 border border-slate-800">
                <button onclick="changeCalMonth(-1)" class="px-3 py-1.5 text-slate-400 hover:text-white transition text-xs font-black">PREV</button>
                <button onclick="goTodayCal()" class="px-3 py-1.5 text-blue-500 hover:bg-blue-500/10 transition text-xs font-black mx-1 rounded-lg">TODAY</button>
                <button onclick="changeCalMonth(1)" class="px-3 py-1.5 text-slate-400 hover:text-white transition text-xs font-black">NEXT</button>
            </div>
        </div>
        <p class="text-[10px] text-slate-500 font-bold tracking-widest uppercase">Company Shared Schedule</p>
    </div>

    <div class="bg-slate-950 rounded-[2rem] border border-slate-800 overflow-hidden shadow-2xl">
        <table class="schedule-cal w-full border-collapse table-fixed">
            <thead>
                <tr class="bg-slate-900/50">
                    <th>SUN</th><th>MON</th><th>TUE</th><th>WED</th><th>THU</th><th>FRI</th><th>SAT</th>
                </tr>
            </thead>
            <tbody id="scheduleBody"></tbody>
        </table>
    </div>
</div>

<div id="eventModal" class="hidden fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm items-center justify-center p-4">
    <div class="bg-slate-900 border border-slate-800 w-full max-w-md rounded-[2rem] p-8 shadow-2xl">
        <div class="flex justify-between items-center mb-6">
            <h3 id="modalTitle" class="text-xl font-black text-white uppercase tracking-tighter">Schedule Entry/Edit</h3>
            <button onclick="closeModal()" class="text-slate-500 hover:text-white text-2xl">&times;</button>
        </div>

        <div id="modalForm" class="space-y-4">
            <div class="modal-input-group">
                <label class="modal-label">Title</label>
                <input type="text" id="evTitle" class="modal-input">
            </div>
            <div class="modal-input-group">
                <label class="modal-label">Description</label>
                <textarea id="evDesc" class="modal-input min-h-[80px] resize-none"></textarea>
            </div>
            
            <div id="adminMemoArea" class="hidden">
                <label class="text-[10px] text-purple-400 font-black uppercase mb-1 block tracking-widest">Admin Memo</label>
                <div id="evAdminMemo" class="text-sm text-slate-300 italic whitespace-pre-wrap memo-display"></div>
            </div>

            <div class="grid grid-cols-2 gap-4">
                <div class="modal-input-group">
                    <label class="modal-label">Start Date</label>
                    <input type="text" id="evStart" class="modal-input cursor-pointer">
                </div>
                <div class="modal-input-group">
                    <label class="modal-label">End Date</label>
                    <input type="text" id="evEnd" class="modal-input cursor-pointer">
                </div>
            </div>
            <label class="checkbox-container text-xs font-bold text-slate-400 flex items-center gap-2 cursor-pointer">
                <input type="checkbox" id="evAllDay" onchange="toggleTimePicker(this.checked)"> All Day Event
            </label>
        </div>

        <div class="flex gap-3 mt-8" id="modalButtons">
            <button id="btnDel" onclick="deleteEvent()" class="hidden flex-1 bg-rose-900/20 text-rose-500 py-4 rounded-xl font-black text-xs hover:bg-rose-900/40 transition">DELETE</button>
            <button id="btnSave" onclick="saveEvent()" class="flex-[2] bg-blue-600 text-white py-4 rounded-xl font-black text-xs hover:bg-blue-500 shadow-lg shadow-blue-900/20 transition uppercase tracking-widest">Save Schedule</button>
        </div>
        <p id="noPermissionMsg" class="hidden text-center text-slate-500 text-[10px] mt-4 font-bold uppercase">View Only Mode</p>
    </div>
</div>


<script>
    (function() {
        const db = firebase.database();
        const user = sessionStorage.getItem('loggedInUser');
        const userRole = sessionStorage.getItem('userRole');
        let calViewDate = new Date();
        let selectedId = null;
        let currentEventData = null;

        let startPicker, endPicker;

        // 시간 선택 토글 함수
        window.toggleTimePicker = (isAllDay) => {
            const config = isAllDay ? {
                enableTime: false,
                dateFormat: "Y-m-d",
                altFormat: "Y-m-d"
            } : {
                enableTime: true,
                dateFormat: "Y-m-d\\TH:i",
                altFormat: "Y-m-d h:i K"
            };
            
            const startVal = startPicker.selectedDates[0];
            const endVal = endPicker.selectedDates[0];
            
            startPicker.set(config);
            endPicker.set(config);
            
            if(startVal) startPicker.setDate(startVal);
            if(endVal) endPicker.setDate(endVal);
        };

        function initPickers() {
            if (typeof flatpickr === 'undefined') { setTimeout(initPickers, 100); return; }
            const baseConfig = { enableTime: true, dateFormat: "Y-m-d\\TH:i", altInput: true, altFormat: "Y-m-d h:i K", time_24hr: false, locale: "en", static: true };
            startPicker = flatpickr("#evStart", baseConfig);
            endPicker = flatpickr("#evEnd", baseConfig);
        }

        window.closeModal = () => { 
            document.getElementById('eventModal').classList.add('hidden'); 
            selectedId = null; 
            currentEventData = null;
        };

        // [수정] 일정 추가 모달: 메모 영역 숨김
        window.openAddModal = (dateStr) => {
            selectedId = null; 
            currentEventData = null;
            document.getElementById('evTitle').value = "";
            document.getElementById('evDesc').value = "";
            document.getElementById('evAllDay').checked = false;
            
            // 메모 영역 초기화 및 숨김
            const memoArea = document.getElementById('adminMemoArea');
            if(memoArea) memoArea.classList.add('hidden');
            const memoDiv = document.getElementById('evAdminMemo');
            if(memoDiv) memoDiv.innerText = "";

            toggleTimePicker(false);
            startPicker.setDate(dateStr + "T09:00");
            endPicker.setDate(dateStr + "T10:00");
            
            document.getElementById('btnDel').classList.add('hidden');
            document.getElementById('btnSave').style.display = 'block';
            document.getElementById('eventModal').classList.replace('hidden', 'flex');
        };

        // [수정] 일정 상세/수정 모달: 메모가 있을 때만 표시 (읽기 전용)
        window.openEditModal = (id, ev) => {
            selectedId = id; 
            currentEventData = ev;
            const canEdit = (ev.author === user || userRole === 'admin');
            
            document.getElementById('evTitle').value = ev.title;
            document.getElementById('evDesc').value = ev.desc || "";
            document.getElementById('evAllDay').checked = ev.allDay || false;
            
            // 관리자 메모 처리 (데이터가 있을 때만 보여줌)
            const memoArea = document.getElementById('adminMemoArea');
            const memoDiv = document.getElementById('evAdminMemo');
            if (memoArea && memoDiv) {
                if (ev.adminMemo) {
                    memoArea.classList.remove('hidden');
                    memoDiv.innerText = ev.adminMemo;
                } else {
                    memoArea.classList.add('hidden');
                    memoDiv.innerText = "";
                }
            }

            toggleTimePicker(ev.allDay);
            startPicker.setDate(ev.start);
            endPicker.setDate(ev.end);

            document.getElementById('btnSave').style.display = canEdit ? 'block' : 'none';
            document.getElementById('btnDel').style.display = canEdit ? 'block' : 'none';
            document.getElementById('eventModal').classList.replace('hidden', 'flex');
        };

        // [수정] 저장 로직: 기존 adminMemo 유실 방지
        window.saveEvent = () => {
            const title = document.getElementById('evTitle').value;
            const isAllDay = document.getElementById('evAllDay').checked;
            const startVal = document.getElementById('evStart').value;
            const endVal = document.getElementById('evEnd').value;

            if(!title || !startVal) return alert("Fill required fields.");

            const data = {
                title: title,
                desc: document.getElementById('evDesc').value || "",
                start: startVal,
                end: endVal || startVal,
                allDay: isAllDay,
                author: selectedId ? currentEventData.author : user,
                timestamp: Date.now()
            };

            // 수정 시 기존 데이터에 adminMemo가 있었다면 보존하여 업데이트
            if (selectedId && currentEventData && currentEventData.adminMemo) {
                data.adminMemo = currentEventData.adminMemo;
            }

            const ref = db.ref('shared_schedules');
            if(selectedId) {
                ref.child(selectedId).update(data).then(closeModal);
            } else {
                ref.push(data).then(closeModal);
            }
        };

        function isDateInRange(targetDateStr, startStr, endStr) {
            const target = new Date(targetDateStr).setHours(0,0,0,0);
            const start = new Date(startStr.split('T')[0]).setHours(0,0,0,0);
            const end = new Date(endStr.split('T')[0]).setHours(0,0,0,0);
            return target >= start && target <= end;
        }

 function renderSchedule() {
        const year = calViewDate.getFullYear(), month = calViewDate.getMonth();
        const firstDay = new Date(year, month, 1).getDay();
        const lastDate = new Date(year, month + 1, 0).getDate();
        const todayStr = new Date().toISOString().split('T')[0];
        document.getElementById('calMonthYear').innerText = calViewDate.toLocaleString('en-US', { month: 'long', year: 'numeric' });

        db.ref('shared_schedules').off();
        db.ref('shared_schedules').on('value', snap => {
            const events = snap.val() || {};
            const tbody = document.getElementById('scheduleBody');
            tbody.innerHTML = '';
            
            // 날짜별로 이미 배치된 이벤트 수를 추적하는 객체 (멀티 라인용)
            const dateSlots = {}; 

            let dateCount = 1;
            for (let i = 0; i < 6; i++) {
                let row = document.createElement('tr');
                for (let j = 0; j < 7; j++) {
                    let cell = document.createElement('td');
                    if (i === 0 && j < firstDay || dateCount > lastDate) { 
                        row.appendChild(cell); 
                    } else {
                        const dStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(dateCount).padStart(2, '0')}`;
                        cell.onclick = (e) => { if(e.target.tagName === 'TD') openAddModal(dStr); };

                        let cellHTML = `<div class="mb-1 pointer-events-none px-2"><span class="text-[10px] font-black ${dStr === todayStr ? 'text-blue-500 bg-blue-500/10 px-1.5 py-0.5 rounded' : 'text-slate-600'}">${dateCount}</span></div>`;
                        
                        // 현재 날짜를 포함하는 모든 이벤트를 필터링하고 시작시간 순으로 정렬
                        const dayEvents = Object.keys(events)
                            .map(id => ({id, ...events[id]}))
                            .filter(ev => {
                                const start = ev.start.split('T')[0];
                                const end = ev.end.split('T')[0];
                                return dStr >= start && dStr <= end;
                            })
                            .sort((a, b) => a.start.localeCompare(b.start));

                        dayEvents.forEach((ev, idx) => {
                            // 이 날짜의 몇 번째 라인에 그려질지 결정
                            if (!dateSlots[dStr]) dateSlots[dStr] = 0;
                            const slotIndex = dateSlots[dStr];
                            
                            let timeLabel = "";
                            if (!ev.allDay && ev.start.includes('T')) {
                                const time = ev.start.split('T')[1].split(':');
                                const hh = parseInt(time[0]);
                                timeLabel = `<span class="opacity-70 mr-1">${hh % 12 || 12}:${time[1]}</span>`;
                            }

                            const evDataString = JSON.stringify(ev).replace(/'/g, "&apos;").replace(/"/g, '&quot;');
                            
                            // 여러 칸에 걸치는 일정 계산
                            const isStartDay = ev.start.split('T')[0] === dStr;
                            let itemWidth = "calc(100% - 6px)";
                            let zIndex = 10;

                            // 시작일일 때만 너비를 확장해서 그림 (멀티데이 지원)
                            if (isStartDay) {
                                const startD = new Date(ev.start.split('T')[0]);
                                const endD = new Date(ev.end.split('T')[0]);
                                const diff = Math.ceil((endD - startD) / (1000 * 60 * 60 * 24)) + 1;
                                itemWidth = `calc(${diff * 100}% - 8px)`;
                                zIndex = 20;
                            } else {
                                // 시작일이 아니면 해당 칸에서는 공간만 차지하고 보이지 않게 처리하거나 
                                // 연속된 막대로 보이게 투명도 조절 가능 (여기서는 단순화를 위해 매일 그림)
                                itemWidth = "calc(100% - 6px)";
                            }

                            const topPos = 30 + (slotIndex * 25); // 25px 간격으로 쌓임

                            cellHTML += `
                                <div onclick='event.stopPropagation(); openEditModal("${ev.id}", ${evDataString})' 
                                     class="event-item ${ev.author === 'admin' ? 'admin-event' : ''}" 
                                     style="width: ${itemWidth}; top: ${topPos}px; z-index: ${zIndex}; ${!isStartDay ? 'opacity: 0.8; border-left: none;' : ''}">
                                    <span class="truncate">${timeLabel}${ev.title}</span>
                                    <span class="ev-staff-tag">${ev.author || 'Staff'}</span>
                                </div>`;
                            
                            dateSlots[dStr]++;
                        });

                        cell.innerHTML = cellHTML;
                        row.appendChild(cell);
                        dateCount++;
                    }
                }
                tbody.appendChild(row);
                if (dateCount > lastDate) break;
            }
        });
    }



        window.changeCalMonth = (offset) => { calViewDate.setMonth(calViewDate.getMonth() + offset); renderSchedule(); };
        window.goTodayCal = () => { calViewDate = new Date(); renderSchedule(); };
        window.deleteEvent = () => { if(confirm("Delete?")) db.ref('shared_schedules/' + selectedId).remove().then(closeModal); };

        initPickers();
        renderSchedule();
    })();
</script>